/* Copyright Institute of Sound and Vibration Research - All rights reserved */

#include "jack_interface.hpp"

#include <libril/constants.hpp>
#include <libpml/index_sequence.hpp>

#include <jack/jack.h>

#include <boost/property_tree/json_parser.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>


#include <cassert>
#include <ciso646> // should not be necessary in C++11, but MSVC is non-compliant here
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>

namespace visr
{
    namespace audiointerfaces
    {
        
        /******************************************************************************/
        /* Definition of the internal implementation class JackInterface::Impl   */
        
        class JackInterface::Impl
        {
        public:
            explicit Impl( Configuration const & baseConfig, std::string const & config );
            
            ~Impl( );
            
            
            void start();
            
            void stop();
            
            bool registerCallback( AudioCallback callback, void* userData );
            
            bool unregisterCallback( AudioCallback audioCallback );
            
        private:
            
            JackInterface::Config parseSpecificConf( std::string const & config );
            
            void process( jack_nframes_t numFrames );
            
            int bufferSizeChange( jack_nframes_t newBufferSize );
            
            int sampleRateChange( jack_nframes_t newSampleRate );
            
            void serverShutdown();
            
            int underrun();
            
            static int processCallbackFunction( jack_nframes_t numFrames, void* arg );
            
            static int bufferSizeCallbackFunction( jack_nframes_t nframes, void *arg );
            
            static int sampleRateCallbackFunction(jack_nframes_t nframes, void *arg);
            
            static void shutdownCallbackFunction( void *arg );
            
            static int underrunCallbackFunction( void *arg );
            
            void registerPorts();
            
            void unregisterPorts();
            
            void connectPorts();
            
            void disconnectPorts();
            
            void setCaptureBuffers( jack_nframes_t numFrames );
            
            void setPlaybackBuffers( jack_nframes_t numFrames );
            
            
            
            std::size_t const mNumCaptureChannels;
            std::size_t const mNumPlaybackChannels;
            
            
            std::size_t const mPeriodSize;
            std::size_t mSampleRate;
            
            
            
            Base::AudioCallback mCallback;
            
            void* mCallbackUserData;
            
            /**
             * Buffer to hold the pointers to the sample vectors for the input
             * of the audio processor.
             * These samples are written from the capture ports of the sound
             * interface and then passed to the audio processing callback function.
             */
            std::vector< SampleType const * > mCaptureSampleBuffers;
            
            /**
             * Buffer to hold the pointers to the sample vectors for the output
             * of the audio processor.
             * These samples are generated by the audio processing callback
             * function and then passed to the playback argument of the
             * portaudio callback function.
             */
            std::vector< SampleType * > mPlaybackSampleBuffers;
            
            jack_client_t* mClient;
            
            
            bool mInitialised;
            
            
            std::string mClientName;
            std::vector<std::string>  mCapturePortNames;
            std::vector<std::string>  mPlaybackPortNames;
            std::vector<std::string>  mInExternalPortNames;
            std::vector<std::string>  mOutExternalPortNames;
            
            std::string mInExtClientName;
            std::string mOutExtClientName;
            bool mInAutoConnect;
            bool mOutAutoConnect;
            
            std::vector<jack_port_t*> mCapturePorts;
            
            std::vector<jack_port_t*> mPlaybackPorts;
            
        };
        
        /******************************************************************************/
        /* Implementation of the JackInterface::Impl class                       */
        
        JackInterface::Impl::Impl( Configuration const & baseConfig, std::string const & conf )
        : mNumCaptureChannels( baseConfig.numCaptureChannels() )
        , mNumPlaybackChannels( baseConfig.numPlayChannels() )
        , mPeriodSize( baseConfig.periodSize() )
        , mSampleRate( baseConfig.sampleRate() )
        , mCallback( nullptr )
        , mCallbackUserData( nullptr )
        , mCaptureSampleBuffers( mNumCaptureChannels, nullptr )
        , mPlaybackSampleBuffers( mNumPlaybackChannels, nullptr )
        , mClient( 0 )
        , mInitialised( false )
        , mCapturePorts( mNumCaptureChannels, nullptr )
        , mPlaybackPorts( mNumPlaybackChannels, nullptr )
        {
            JackInterface::Config config = parseSpecificConf(conf);
            
            //            config.loadPortConfigJson(config.mPortJSONConfig, mNumCaptureChannels, mNumPlaybackChannels);
            
            if(!config.mPortJSONConfig.empty()){
                boost::property_tree::ptree ptype;
                ptype = config.mPortJSONConfig.get_child("capture");
                config.loadPortConfig(ptype, config.mInExtClientName, config.mCapturePortNames, mInExternalPortNames, mNumCaptureChannels, config.mInAutoConnect);
                ptype = config.mPortJSONConfig.get_child("playback");
                config.loadPortConfig(ptype, config.mOutExtClientName, config.mPlaybackPortNames, mOutExternalPortNames, mNumPlaybackChannels, config.mOutAutoConnect);
            }
            if(!config.mClientName.empty()) mClientName = config.mClientName;
            else mClientName = "JackClient";
            
            
            std::sort(config.mCapturePortNames.begin(),config.mCapturePortNames.end());
            std::sort(config.mPlaybackPortNames.begin(),config.mPlaybackPortNames.end());
            if(std::adjacent_find(config.mCapturePortNames.begin(),config.mCapturePortNames.end())!=config.mCapturePortNames.end())
            {
                std::cout<<"mCapPorts: "<< mCapturePortNames.size()<<" mCapChan: "<< mNumCaptureChannels<< std::endl;
                throw std::invalid_argument( "JackInterface: Duplicate port names are not allowed, as well as overlapping indices" );
            }
            if(std::adjacent_find(config.mPlaybackPortNames.begin(),config.mPlaybackPortNames.end())!=config.mPlaybackPortNames.end())
            {
                throw std::invalid_argument( "JackInterface: Duplicate port names are not allowed, as well as overlapping indices" );
            }
            
            
            

            mCapturePortNames = config.mCapturePortNames;
            mPlaybackPortNames = config.mPlaybackPortNames;
            
            mInExtClientName = config.mInExtClientName;
            mOutExtClientName = config.mOutExtClientName;
            mInAutoConnect = config.mInAutoConnect;
            mOutAutoConnect = config.mOutAutoConnect;
            
            if( mCapturePortNames.size() != mNumCaptureChannels )
            {
                std::cout<<"mCapPorts: "<< mCapturePortNames.size()<<" mCapChan: "<< mNumCaptureChannels<< std::endl;
                throw std::invalid_argument( "JackInterface: The list of capture port names must have the same number of elements as the capture width." );
            }
            if( mPlaybackPortNames.size() != mNumPlaybackChannels )
            {
                throw std::invalid_argument( "JackInterface: The list of playback port names must have the same number of elements as the playback width." );
            }
            
            
            char const * const serverName = config.mServerName.empty() ? "default" : config.mServerName.c_str();
            char const * const clientName = mClientName.c_str();
            
            jack_status_t status;
            jack_options_t options = static_cast<jack_options_t>(JackNoStartServer | JackServerName | JackUseExactName);
            mClient = jack_client_open( clientName, options, &status, serverName );
            if( (status & JackFailure) or !mClient )
            {
                throw std::invalid_argument( "JackInterface: Opening of client failed." );
            }
            if( jack_set_process_callback( mClient, &Impl::processCallbackFunction, this ) != 0 )
            {
                throw std::logic_error( "JackInterface: Error registering process callback." );
            }
            if( jack_set_buffer_size_callback( mClient, &Impl::bufferSizeCallbackFunction, this ) != 0 )
            {
                throw std::logic_error( "JackInterface: Error registering buffer size callback." );
            }
            if( jack_set_sample_rate_callback( mClient, &Impl::sampleRateCallbackFunction, this ) != 0 )
            {
                throw std::logic_error( "JackInterface: Error registering sample rate callback." );
            }
            // Note: The shutdown stuff is inconsistent with the other callback/registering interfaces.
            jack_on_shutdown( mClient, &Impl::shutdownCallbackFunction, this );
            if( jack_set_xrun_callback( mClient, &Impl::underrunCallbackFunction, this ) != 0 )
            {
                throw std::logic_error( "JackInterface: Error registering underrun callback." );
            }
            int const res = jack_set_buffer_size( mClient, static_cast<jack_nframes_t>(mPeriodSize) );
            if( res != 0 )
            {
                throw std::logic_error( "JackInterface: Setting the buffer size failed." );
            }
            
            jack_nframes_t const jackSampleRate = jack_get_sample_rate( mClient );
            //            std::cout<<"PERIOD: "<<mPeriodSize<<" SR: "<<jackSampleRate<<std::endl;
            if( jackSampleRate != static_cast<jack_nframes_t>(mSampleRate) )
            {
                throw std::logic_error( "JackInterface: The sample rate of the server differs from the requested sample rate of the client." );
            }
        }
        
        JackInterface::Impl::~Impl()
        {
            stop();
            int const res = jack_client_close( mClient );
            if( res != 0 ) // Destructors mustn't throw
            {
                std::cerr << "JackInterface: Error while closing Jack client." << std::endl;
            }
        }
        
        JackInterface::Config JackInterface::Impl::parseSpecificConf( std::string const & config ){
            //            std::basic_istream<char> stream
            std::stringstream stream(config);
            //            std::cout<< "STREAM: "<<stream.str()<<std::endl;
            boost::property_tree::ptree tree;
            try
            {
                read_json( stream, tree );
            }
            catch( std::exception const & ex )
            {
                throw std::invalid_argument( std::string( "Error while parsing a json node: " ) + ex.what( ) );
            }
            boost::optional<std::string> cliN;
            boost::optional<std::string> servN;
            boost::optional<bool> autoC;
            boost::optional<const boost::property_tree::ptree&> portsC;
            std::string cliName="";
            std::string servName="";
            bool autoConn = false;
            boost::property_tree::ptree portsConfig;
            
            
            cliN = tree.get_optional<std::string>( "clientname" );
            servN = tree.get_optional<std::string>( "servername" );
            portsC = tree.get_child_optional("portconfig");
            autoC = tree.get_optional<bool>( "autoconnect" );
            
            
            if(cliN) cliName = *cliN;
            if(servN) servName = *servN;
            if(portsC){
                
                //                std::ostringstream oss;
                //                boost::property_tree::ptree ports = *portsC;
                //                boost::property_tree::ini_parser::write_ini(oss, ports);
                //            portsConfig = oss.str();
                portsConfig = *portsC;
                
            }
            if(autoC) autoConn = *autoC;
            //            std::cout<<"CLI: "<<cliName<<" SERV: "<<servName<<" PORTCONF: "<<std::endl;
            return Config(cliName, servName, portsConfig, autoConn);
            
        }
        
        void JackInterface::Impl::registerPorts()
        {
            for( std::size_t captureIdx(0); captureIdx < mNumCaptureChannels; ++captureIdx )
            {
//                std::cout<< "REGISTERING PORTNAME: "<<mCapturePortNames[captureIdx].c_str()<<std::endl;
                jack_port_t * newPort = jack_port_register( mClient,
                                                           mCapturePortNames[captureIdx].c_str(),
                                                           JACK_DEFAULT_AUDIO_TYPE,
                                                           JackPortIsInput,
                                                           0 /* buffer size is ignored for built-in types */ );
                if( newPort == nullptr )
                {
                    unregisterPorts();
                    throw std::runtime_error( "JackInterface: Registering of port failed." );
                }
                else
                {
                    mCapturePorts[captureIdx] = newPort;
                }
            }
            for( std::size_t playbackIdx(0); playbackIdx < mNumPlaybackChannels; ++playbackIdx )
            {
                jack_port_t * newPort = jack_port_register( mClient,
                                                           mPlaybackPortNames[playbackIdx].c_str(),
                                                           JACK_DEFAULT_AUDIO_TYPE,
                                                           JackPortIsOutput,
                                                           0 /* buffer size is ignored for built-in types */ );
                if( newPort == nullptr )
                {
                    unregisterPorts();
                    throw std::runtime_error( "JackInterface: Registering of port failed." );
                }
                else
                {
                    mPlaybackPorts[playbackIdx] = newPort;
                }
            }
        }
        
        void JackInterface::Impl::unregisterPorts()
        {
            for( std::size_t captureIdx(0); captureIdx < mNumCaptureChannels; ++captureIdx )
            {
                if( mCapturePorts[captureIdx] == nullptr )
                {
                    continue;
                }
                int const res = jack_port_unregister( mClient, mCapturePorts[captureIdx] );
                if( res != 0 )
                {
                    std::cerr << "JackInterface: Error while unregistering port" << std::endl;
                }
                mCapturePorts[captureIdx] = nullptr;
            }
            for( std::size_t playbackIdx(0); playbackIdx < mNumPlaybackChannels; ++playbackIdx )
            {
                if( mPlaybackPorts[playbackIdx] == nullptr )
                {
                    continue;
                }
                int const res = jack_port_unregister( mClient, mPlaybackPorts[playbackIdx] );
                if( res != 0 )
                {
                    std::cerr << "JackInterface: Error while unregistering port" << std::endl;
                }
                mPlaybackPorts[playbackIdx] = nullptr;
            }
        }
        
        void JackInterface::Impl::connectPorts()
        {
            
            //            std::cout<<"Connections: "<<std::endl;
            if(mInAutoConnect){
                
                
                //                const char **ports;
                //                if ((ports = jack_get_ports (mClient, NULL, NULL, JackPortIsPhysical|JackPortIsOutput)) == NULL) {
                //                    fprintf(stderr, "Cannot find any physical capture ports\n");
                //                    exit(1);
                //                }
                //
                
                for( std::size_t captureIdx(0); captureIdx < mNumCaptureChannels; ++captureIdx )
                {
                    char const * name = (mClientName +":"+ mCapturePortNames[captureIdx]).c_str();
                    //                std::cout<<ports[captureIdx] << " ----> "<<name << std::endl;
                    
                    char const * nameExt = (mInExtClientName +":"+ mInExternalPortNames[captureIdx]).c_str();
                    //                    std::cout<<nameExt << " ----> "<<name << std::endl;
                    if (jack_connect (mClient, nameExt, name)){
                        fprintf (stderr, "cannot connect input ports\n");
                    }
                    //                    if (jack_connect (mClient, ports[captureIdx], name)){
                    //                        fprintf (stderr, "cannot connect input ports\n");
                    //                    }
                }
                
                //                free (ports);
            }
            if(mOutAutoConnect){
                //                const char **ports;
                
                //                if ((ports = jack_get_ports (mClient, NULL, NULL, JackPortIsPhysical|JackPortIsInput)) == NULL) {
                //                    fprintf(stderr, "Cannot find any physical playback ports\n");
                //                    exit(1);
                //                }
                //
                
                for( std::size_t playbackIdx(0); playbackIdx < mNumPlaybackChannels; ++playbackIdx )
                {
                    char const * name = (mClientName +":"+ mPlaybackPortNames[playbackIdx]).c_str();
                    //                std::cout<<ports[playbackIdx] << " <---- "<<name << std::endl;
                    char const * nameExt = (mOutExtClientName +":"+ mOutExternalPortNames[playbackIdx]).c_str();
                    
                    //                    std::cout<<nameExt << " ----> "<<name << std::endl;
                    
                    if (jack_connect (mClient, name, nameExt)) {
                        fprintf (stderr, "cannot connect output ports\n");
                    }
                    //                    if (jack_connect (mClient, name, ports[playbackIdx])) {
                    //                        fprintf (stderr, "cannot connect output ports\n");
                    //                    }
                }
                //                free (ports);
            }
        }
        
        void JackInterface::Impl::disconnectPorts()
        {
            if(mInAutoConnect){
                
                for( std::size_t captureIdx(0); captureIdx < mNumCaptureChannels; ++captureIdx )
                {
                    char const * name = (mClientName +":"+ mCapturePortNames[captureIdx]).c_str();
                    //                std::cout<<ports[captureIdx] << " ----> "<<name << std::endl;
                    char const * nameExt = (mInExtClientName +":"+ mInExternalPortNames[captureIdx]).c_str();
                    
                    if (jack_disconnect (mClient, nameExt, name)){
                        fprintf (stderr, "cannot disconnect input ports\n");
                    }
                }
            }
            
            if(mOutAutoConnect){
                for( std::size_t playbackIdx(0); playbackIdx < mNumPlaybackChannels; ++playbackIdx )
                {
                    char const * name = (mClientName +":"+ mPlaybackPortNames[playbackIdx]).c_str();
                    //                std::cout<<ports[playbackIdx] << " <---- "<<name << std::endl;
                    char const * nameExt = (mOutExtClientName +":"+ mOutExternalPortNames[playbackIdx]).c_str();
                    
                    if (jack_disconnect (mClient, name, nameExt)) {
                        fprintf (stderr, "cannot disconnect output ports\n");
                    }
                }
            }
            
        }
        
        void JackInterface::Impl::start()
        {
            if( mInitialised )
            {
                disconnectPorts();
                unregisterPorts();
                mInitialised = false;
            }
            int const res = jack_activate( mClient );
            if( res != 0 )
            {
                throw std::runtime_error( "JackInterface::Impl::start() returned an error." );
            }
            registerPorts();
            connectPorts();
            mInitialised = true;
        }
        
        void JackInterface::Impl::stop()
        {
            mInitialised = false;
            disconnectPorts();
            unregisterPorts(); // This ensures that the port pointers are properly reset.
            int const res = jack_deactivate( mClient );
            if( res != 0 )
            {
                throw std::runtime_error( "JackInterface::Impl::stop() returned an error." );
            }
        }
        
        bool JackInterface::Impl::registerCallback( AudioCallback callback, void* userData )
        {
            mCallback = callback;
            mCallbackUserData = userData;
            return true;
        }
        
        bool JackInterface::Impl::unregisterCallback( AudioCallback callback )
        {
            if( mCallback == callback )
            {
                mCallback = nullptr;
                mCallbackUserData = nullptr;
                return true;
            }
            else
            {
                return false;
            }
        }
        
        int JackInterface::Impl::bufferSizeChange( jack_nframes_t newBufferSize )
        {
            return 0;
        }
        
        int JackInterface::Impl::sampleRateChange( jack_nframes_t newSampleRate )
        {
            return 0;
        }
        
        void JackInterface::Impl::serverShutdown()
        {
            std::cerr << "JackInterface: Noticed about server shutdown." << std::endl;
        }
        
        int JackInterface::Impl::underrun()
        {
            return 0;
        }
        
        /*static*/ int
        JackInterface::Impl::processCallbackFunction( jack_nframes_t numFrames, void* arg )
        {
            Impl* me = reinterpret_cast<Impl*>( arg );
            try
            {
                me->process( numFrames );
            }
            catch( std::exception const & ex )
            {
                std::cerr << "JackInterface: Error while executing process function: " << ex.what() << std::endl;
                return 1;
            }
            return 0;
        }
        
        /*static*/ int JackInterface::Impl::bufferSizeCallbackFunction( jack_nframes_t nframes, void *arg )
        {
            return static_cast<Impl*>(arg)->bufferSizeChange( nframes );
        }
        
        /*static*/ int JackInterface::Impl::sampleRateCallbackFunction(jack_nframes_t nframes, void *arg)
        {
            return static_cast<Impl*>(arg)->sampleRateChange( nframes );
        }
        
        /*static*/ void JackInterface::Impl::shutdownCallbackFunction( void *arg )
        {
            static_cast<Impl*>(arg)->serverShutdown( );
        }
        
        /*static*/ int JackInterface::Impl::underrunCallbackFunction( void *arg )
        {
            return static_cast<Impl*>(arg)->underrun( );
        }
        
        void JackInterface::Impl::process( jack_nframes_t numFrames )
        {
            // TODO: More flexible handling of the buffer size
            if( static_cast<jack_nframes_t>( mPeriodSize ) != numFrames )
            {
                throw std::logic_error( "JackInterface: Wrong buffer size." );
            }
            
            if( mCallback and mInitialised )
            {
                setCaptureBuffers( numFrames );
                setPlaybackBuffers( numFrames );
                CallbackResult res;
                // Exceptions are caught by the calling static function.
                (*mCallback)(mCallbackUserData, &mCaptureSampleBuffers[0], &mPlaybackSampleBuffers[0], res);
            }
            else
            {
                // no registered callback function is no error. We should think about clearing the output buffers.
            }
        }
        
        void JackInterface::Impl::setCaptureBuffers( jack_nframes_t numFrames )
        {
            for( std::size_t captureIdx(0); captureIdx < mCapturePorts.size(); ++captureIdx )
            {
                SampleType const * const capturePtr
                = static_cast<SampleType const * const>(jack_port_get_buffer( mCapturePorts[captureIdx],
                                                                             numFrames ));
                assert( capturePtr );
                mCaptureSampleBuffers[captureIdx] = capturePtr;
            }
        }
        
        void JackInterface::Impl::setPlaybackBuffers( jack_nframes_t numFrames )
        {
            for( std::size_t playbackIdx(0); playbackIdx < mPlaybackPorts.size(); ++playbackIdx )
            {
                SampleType * const playbackPtr
                = static_cast<SampleType * const>(jack_port_get_buffer( mPlaybackPorts[playbackIdx],
                                                                       numFrames ));
                assert( playbackPtr );
                mPlaybackSampleBuffers[playbackIdx] = playbackPtr;
            }
        }
        
        /******************************************************************************/
        /* PortAudioInterface implementation                                          */
        
        JackInterface::JackInterface(Configuration const & baseConfig , std::string const & config )
        : mImpl( new Impl( baseConfig, config ) )
        {
        }
        
        JackInterface::~JackInterface( )
        {
            // nothing to be done, as all cleanup is performed in the implementation object.
        }
        
        
        void JackInterface::start()
        {
            mImpl->start();
        }
        
        void JackInterface::stop()
        {
            mImpl->stop();
        }
        
        /*virtual*/ bool
        JackInterface::registerCallback( AudioCallback callback, void* userData )
        {
            return mImpl->registerCallback( callback, userData );
        }
        
        /*virtual*/ bool
        JackInterface::unregisterCallback( AudioCallback callback )
        {
            return mImpl->unregisterCallback( callback );
        }
        
        //        void JackInterface::Config::loadJson(boost::property_tree::ptree tree, int numCapt, int numPlay )
        //        {
        //
        //            int i = 0;
        //            boost::optional<std::string> captBaseName;
        //            boost::optional<std::string> inIdxStr;
        //            boost::optional<std::string> playBaseName;
        //            boost::optional<std::string> outIdxStr;
        //            if(!tree.empty()){
        //            for(boost::property_tree::ptree::value_type &temp : tree.get_child( "ports")){
        //                for(boost::property_tree::ptree::value_type &t2 : temp.second){
        //                    //                      std::cout<<t2.first<< ": "<<t2.second.data()<<std::endl;
        //                    //                std::cout<<t2.first<<std::endl;
        //                    if(t2.first == "captbasename"){
        //                        captBaseName = temp.second.get_optional<std::string>( "captbasename" );
        //
        //                        inIdxStr = temp.second.get_optional<std::string>( "inindexes" );
        //
        //                    }else if(t2.first =="playbasename"){
        //                        playBaseName = temp.second.get_optional<std::string>( "playbasename" );
        //
        //                        outIdxStr = temp.second.get_optional<std::string>( "outindexes" );
        //                    }
        //                    i++;
        //                }
        //            }
        //            }
        //            if(!captBaseName){
        //                captBaseName ="capture" ;
        //                if(inIdxStr){
        //                    //err?
        //                }
        //            }
        //
        //            if(inIdxStr){
        //                visr::pml::IndexSequence const inIndices( *inIdxStr );
        //                std::size_t const inNumEntries = inIndices.size( );
        //                mCapturePortNames.resize( inNumEntries );
        //
        //                for( std::size_t entryIdx( 0 ); entryIdx < inNumEntries; ++entryIdx )
        //                {
        //                    std::stringstream str;
        //                    str << *captBaseName << inIndices[entryIdx];
        //                    mCapturePortNames[entryIdx] = str.str();
        //                }
        //            }else{
        //                mCapturePortNames.resize( numCapt );
        //                for( std::size_t entryIdx( 0 ); entryIdx < numCapt; ++entryIdx )
        //                {
        //                    std::stringstream str;
        //                    str << *captBaseName << entryIdx;
        //                    mCapturePortNames[entryIdx] = str.str();
        //                }
        //            }
        //
        //
        //            if(!playBaseName){
        //                playBaseName = "playback";
        //                if (outIdxStr){
        //                    //err?
        //                }
        //            }
        //
        //            if (outIdxStr){
        //                visr::pml::IndexSequence const outIndices( *outIdxStr );
        //                std::size_t const outNumEntries = outIndices.size( );
        //                mPlaybackPortNames.resize( outNumEntries );
        //
        //                for( std::size_t entryIdx( 0 ); entryIdx < outNumEntries; ++entryIdx )
        //                {
        //                    std::stringstream str;
        //                    str << *playBaseName << outIndices[entryIdx];
        //                    mPlaybackPortNames[entryIdx] = str.str();
        //                }
        //
        //            }else{
        //                mPlaybackPortNames.resize( numPlay );
        //                for( std::size_t entryIdx( 0 ); entryIdx < numPlay; ++entryIdx )
        //                {
        //                    std::stringstream str;
        //                    str << *playBaseName << entryIdx;
        //                    mPlaybackPortNames[entryIdx] = str.str();
        //                }
        //            }
        //        }
        //        }
        
        void JackInterface::Config::loadPortConfigJson(boost::property_tree::ptree tree, int numCapt, int numPlay )
        {
            
            if(!tree.empty()){
                //                for(boost::property_tree::ptree::value_type &root : tree.get_child("portconfig")){
                ////                    for(boost::property_tree::ptree::value_type &t2 : temp.second){
                //                                              std::cout<<root.first<< ": "<<root.second.data()<<std::endl;
                //                    std::string porttype = root.first;
                //                for(boost::property_tree::ptree::value_type &ptype : root.second){
                //                boost::property_tree::ptree ptype;
                //                ptype = tree.get_child("capture");
                //                loadPorts(ptype,"capture",numCapt,numPlay);
                //                ptype = tree.get_child("playback");
                //                loadPorts(ptype,"playback",numCapt,numPlay);
                //
                //                                        std::cout<<temp.first<<std::endl;
                //                        if(t2.first == "captbasename"){
                //                            captBaseName = temp.second.get_optional<std::string>( "captbasename" );
                //
                //                            inIdxStr = temp.second.get_optional<std::string>( "inindexes" );
                //
                //                        }else if(t2.first =="playbasename"){
                //                            playBaseName = temp.second.get_optional<std::string>( "playbasename" );
                //
                //                            outIdxStr = temp.second.get_optional<std::string>( "outindexes" );
                //                        }
                //                        i++;
                //                    }
                //                }
            }
            
        }
        
        void JackInterface::Config::loadPortConfig(boost::property_tree::ptree tree, std::string & extClientName, std::vector< std::string > & portNames, std::vector< std::string > & extPortNames, int numPorts, bool & autoConn){
            if(!tree.empty()){
                boost::optional<bool> autoConnect;
                boost::optional<std::string> baseName;
                boost::optional<std::string> indicesStr;
                boost::optional<std::string> extBaseName;
                boost::optional<std::string> extIndicesStr;
                boost::optional<std::string> extClient;
                
                boost::property_tree::ptree port, extPort;
                
                //                for(boost::property_tree::ptree::value_type &root : tree.get_child(type)){
                //                    for(boost::property_tree::ptree::value_type &t2 : temp.second){
                //                    std::cout<<root.first<< ": "<<root.second.data()<<std::endl;
                autoConnect = tree.get_optional<bool>( "autoconnect" );
                if(autoConnect) autoConn = *autoConnect;
                
                
                 portNames.resize( numPorts );
                extPortNames.resize( numPorts );
                 std::size_t globalIdx( 0 );
                std::size_t extGlobalIdx( 0 );
               
                for(boost::property_tree::ptree::value_type &pconf : tree.get_child("port")){
                    //                    std::cout<<pconf.first<< ": "<<pconf.second.data()<<std::endl;
                    baseName = pconf.second.get_optional<std::string>( "basename" );
                    indicesStr = pconf.second.get_optional<std::string>( "indices" );
                    extPort = pconf.second.get_child("externalport");
                    //                    std::cout<<baseName<< ", "<<indicesStr<<std::endl;
                    if(indicesStr && baseName){
                        visr::pml::IndexSequence const inIndices( *indicesStr );
                        std::size_t const inNumEntries = inIndices.size( );
//                        portNames.resize( inNumEntries );
                        
                        for( std::size_t entryIdx( 0 ) ; entryIdx < inNumEntries; ++entryIdx, ++globalIdx )
                        {
                            std::stringstream str;
                            str << *baseName << inIndices[entryIdx];
//                            std::cout<<"PORTNAMES: "<<str.str()<<" GLOB: "<<globalIdx<<std::endl;

                            portNames[globalIdx] = str.str();
                        }
                    }else{
                        if(!baseName){
                            baseName ="visr" ;
                        }
                       
                        for(std::size_t entryIdx( 0 ); entryIdx < numPorts; ++entryIdx, ++globalIdx)
                        {
                            std::stringstream str;
                            str << *baseName << entryIdx;
                            portNames[globalIdx] = str.str();
                        }
                    }
                    
                    
                    if(autoConn){
                        extClient = extPort.get_optional<std::string>( "client" );
                        extBaseName = extPort.get_optional<std::string>( "portname" );
                        extIndicesStr = extPort.get_optional<std::string>( "indices" );
                        //                                        std::cout<<"TREEDATA: "<< ", "<<tree.data()<<std::endl;
                        if(!extClient){
                            throw std::invalid_argument( "JackInterface: if autoconnect is true you must specify external client's name" );
                        }
                        if(!extBaseName){
                            throw std::invalid_argument( "JackInterface: if autoconnect is true you must specify external client's port basename" );
                        }
                        extClientName = *extClient;
                        if(extIndicesStr){
                            visr::pml::IndexSequence const extInIndices( *extIndicesStr );
                            std::size_t const extInNumEntries = extInIndices.size( );
                            
                            
                            for( std::size_t extEntryIdx( 0 ); extEntryIdx < extInNumEntries; ++extEntryIdx,++extGlobalIdx )
                            {
                                std::stringstream str;
                                str << *extBaseName << extInIndices[extEntryIdx];
//                               std::cout<<"EXTPORTNAMES: "<<str.str()<<" GLOB: "<<extGlobalIdx<<std::endl;
                                extPortNames[extGlobalIdx] = str.str();
                            }
                        }else{
                            
                            for( std::size_t extEntryIdx( 0 ); extEntryIdx < numPorts; ++extEntryIdx,++extGlobalIdx )
                            {
                                std::stringstream str;
                                str << *extBaseName << extEntryIdx;
                                extPortNames[extGlobalIdx] = str.str();
                            }
                        }
                    }
                }
                
                //                for(boost::property_tree::ptree::value_type &pconf : tree.get_child("externalport")){
                //                    //                    std::cout<<pconf.first<< ": "<<pconf.second.data()<<std::endl;
                //
                //                }
                
            }
        }
        
        
        void JackInterface::Config::setCapturePortNames( std::string const baseName,
                                                        std::size_t startIndex,
                                                        std::size_t endIndex )
        {
            if( startIndex > endIndex )
            {
                throw std::invalid_argument( "JackInterface::Config::setCapturePortNames(): start index exceeds end index." );
            }
            std::size_t const numPorts = endIndex - startIndex + 1;
            mCapturePortNames.resize( numPorts );
            for( std::size_t runIdx( 0 ); runIdx < numPorts; ++runIdx )
            {
                std::stringstream str;
                str << baseName << runIdx;
                mCapturePortNames[runIdx] = str.str();
            }
        }
        
        void JackInterface::Config::setPlaybackPortNames( std::string const baseName,
                                                         std::size_t startIndex, std::size_t endIndex )
        {
            if( startIndex > endIndex )
            {
                throw std::invalid_argument( "JackInterface::Config::setPlaybackPortNames(): start index exceeds end index." );
            }
            std::size_t const numPorts = endIndex - startIndex + 1;
            mPlaybackPortNames.resize( numPorts );
            for( std::size_t runIdx( 0 ); runIdx < numPorts; ++runIdx )
            {
                std::stringstream str;
                str << baseName << runIdx;
                mPlaybackPortNames[runIdx] = str.str();
            }
        }
        
        
        
        
    } // namespace rrl
} // namespace visr
