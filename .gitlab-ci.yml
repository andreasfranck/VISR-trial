stages:
  - cmake
  - compile and test
  - documentation
  - package
  - deployment

# Runners (currently tagged in jobs):
# - nifty -   MacOS
# - kane -    Linuxgcc4++
# - usain -   Windows

# Changing the key will clear the cache, and you can store it in a different location with a predefined variable.
# Change this by doing $ export CI_PROJECT_NAME='VISR' && export CI_BUILD_REF_NAME="path/of/new/cache"
cache:
  # key: "$CI_PROJECT_NAME/$CI_BUILD_REF_NAME"
  paths:
    - ./build/

# Note - please look at remote/origin/ci-integration-experimental for a more detailed outlook on future ci work

# For the time being, pushing should only occur manually, and

########### cmake ###########

# Linux:Freshly:Requirements:
# - To make a fresh build from scratch
# - Build and compile with documentation and sphinx
# - With other options - python bindings too?
# - Only trigger this job via variable
# - package and build binaries
# - Upload binary artifacts for website
Linux:Freshly:
  stage: cmake
  variables:
    CI_DEBUG_TRACE: "true"
  before_script:
    - if [ -d build/ ] ; then rm -R build/; fi
    - mkdir build
  script:
    - if [ -d build/ ] ; then cd build/ && cmake -DBUILD_DOCUMENTATION_SPHINX=ON .. && make && make doxy && make webapi; fi
    - chmod 777 ../build
    # - make package
  # Pass artifacts to deployment stage
  artifacts:
    paths:
      - build/
  cache:
    paths:
      - build/
  only:
    - feature/sphinx-ci-integration
    # This job can be triggered by exporting a variable in terminal, like:
    # variables:
    #   - $CI_COMMIT_MESSAGE == "Run fresh build"
  tags:
    - linux
    - ubuntu16

# The default behaviour of a caching job is to download the files at the start of execution, and to re-upload them at the end. This allows any changes made by the job to be persisted for future runs, and is known as the pull-push cache policy.

# Linux:Cachely:Requirements:
# - To make from a cache. Must have artifacts from

# Future request https://gitlab.com/gitlab-org/gitlab-ce/issues/23902 on pipelines for merge requests
Linux:Cachely:
  stage: compile and test
  script:
    - if [ -d build/ ] ; then cd build/ && make && make doxy && make webapi; fi
  cache:
    paths:
      - build/
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16

    # Add variable here to trigger
Linux:SphinxAPI:
  stage: documentation
  script:
    - if [ -d build/ ] ; then cd build/ && make && make doxy and make webapi; fi
  # Dependent on previous linux build stage
  # Want to have either Linux:Cachely or Linux:Freshly , not both for faster pipeline triggers on merge
  cache:
    paths:
      - build/
      # This policy is to download the files at the start of execution and re-upload them at the end. This allows any changes made by the job to be persisted for future runs, known as the pull-push cache policy.
      # If we know that the job doesnt' alter the cached files, you can skip the upload step by setting this policy: pull in the job spec.
    policy: pull
  dependencies:
    - Linux:Cachely
  artifacts:
    paths:
      - build/
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16

# Doxygen:
#   stage: documentation
#   before_script:
#     - if [ -d /build ] ; then rm -R /build; fi
#   script:
#     - mkdir build && cd build
#     - cmake -DBUILD_DOCUMENTATION=ON ..
#   # Pass artifacts to various jobs
#   artifacts:
#     paths:
#       - build/
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS


# Uses cmake to create with the XCode Generator option -G
# MacOS:Xcode:
#   stage: build
#   before_script:
#     - if [ -d /build ] ; then rm -R /build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake -G Xcode ../VISR
#   artifacts:
#
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS
#   allow_failure: true
#
# # Enables python bindings
# MacOS:Python:
#   stage: build
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     # Note here that if you brew boost libraries, you will encounter errors when cmake tries to find it. It is not located in /usr/local/lib when installed via brew.
#     - cmake -DBUILD_PYTHON_BINDINGS=ON ../VISR
#     # - make
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS
#   allow_failure: true

#
# Linux:Python:
#   stage: build
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake -DBUILD_PYTHON_BINDINGS=ON ../VISR
#     - make
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - linux
#     - ubuntu16
#   allow_failure: true
#
#
# ########### compile ###########
#
# MacOS:Core:
#   stage: compile & test
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake ../VISR
#     - make
#     - ctest -C Debug -j8
#     - ctest -R rrl_test
#     - ctest -j8 -R
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS
#   allow_failure: true
#
# Linux:Core:
#   stage: compile & test
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake ../VISR
#     - make
#     - ctest -C Debug -j8
#     - ctest -R rrl_test
#     - ctest -j8 -R
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - linux
#     - ubuntu16
#   allow_failure: true
#   # variables:
#   artifacts:
#     paths:
#     - Testing/*.log
#     expire_in: 1 week

########### deploy ############

#You can only use paths that are within the project workspace. To pass artifacts between different jobs, see dependencies.

Linux:WebAPI:
  stage: deployment
  # before_script:
  #   - if [ -d ../build ] ; then rm -R ../build; fi
  script:
    # - mkdir build && cd build
    # - cmake -DBUILD_DOCUMENTATION_SPHINX=ON ..
    # - make doxy
    # - make webapi
    # is this accessing the id_rsa private or public key?
    # -r recursive, -h human-readable, -z compress -v versbose
    # --delete delete extreneous files from dest dirs
    # -e specify the remote shell to use with
    # ssh -i identity file which contains the private key. Teh default is ~/.ssh/id_dsa, ecdsa, id_rsa.
    # Where does wm0014 directory begin ? is this cwd? or goes to $HOME?

    #
    # rsync av --update /loc1 /loc2
    # av --update so only files that are NEWER will be synced from loc1 to loc2. Logic dictates that any files that are NEWER on loc2 will be # untouched. Therefore all the      outdated files on loc2 will be up-to-date thanks to loc1
    # - yes | cp -rf doc/sphinx /vol/vssp/dataweb/data/s3a/public/VISRWeb
    # - rsync -hrvz --update -e "ssh -i " wm0014@cvssp.org:~/.ssh/builds/cfa3a610/0/s3a/VISR/build/doc /vol/vssp/dataweb/data/s3a/public/VISRWeb
    # - cd build/doc/sphinx && ls -la
    - rsync -h -v -r -P -t ~/.ssh/builds/cfa3a610/0/s3a/VISR/build/ /vol/vssp/dataweb/data/s3a/public/VISRWeb
  # # Each time a job suceeds , a deployment is recorded, remembering the git SHA and environment name.
  # environment:
  #   name: staging
  #   url: ???
  # artifacts:
  #   paths:
  #     - build/doc/sphinx
  dependencies:
    - Linux:SphinxAPI
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16
