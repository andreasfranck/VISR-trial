stages:
  - build
  - documentation
  - compile and test
  - deployment

# Runners (currently tagged in jobs):
# - nifty -   MacOS
# - kane -    Linuxgcc4++
# - usain -   Windows

# Note - please look at remote/origin/ci-integration-experimental for a more detailed outlook on future ci work

# For the time being, pushing should only occur manually, and

########### build ###########

########### documentation ###########

Linux:Freshly:
  stage: build
  before_script:
    - if [ -d build/ ] ; then rm -R build/; fi
  script:
    - mkdir build && cd build
    - chmod 777 ../build
    - cmake -DBUILD_DOCUMENTATION=ON -DBUILD_DOCUMENTATION_SPHINX=ON ..
    - make
  # Pass artifacts to deployment stage
  artifacts:
    paths:
      - build/
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16

Linux:Cachely:
  stage: build
  script:
    - cd build
    - make
    # Pass artifacts to deployment stage
  artifacts:
    paths:
      - build/
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16

    # Add variable here to trigger

Linux:SphinxAPI:
  stage: documentation
  script:
    - cd build
    - make doxy
    - make webapi
  # Dependent on previous linux build stage
  # Want to have either Linux:Cachely or Linux:Freshly , not both for faster pipeline triggers on merge
  dependencies:
    - Linux:Build
  artifacts:
    paths:
      - build/
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16



# Doxygen:
#   stage: documentation
#   before_script:
#     - if [ -d /build ] ; then rm -R /build; fi
#   script:
#     - mkdir build && cd build
#     - cmake -DBUILD_DOCUMENTATION=ON ..
#   # Pass artifacts to various jobs
#   artifacts:
#     paths:
#       - build/
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS


# Uses cmake to create with the XCode Generator option -G
# MacOS:Xcode:
#   stage: build
#   before_script:
#     - if [ -d /build ] ; then rm -R /build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake -G Xcode ../VISR
#   artifacts:
#
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS
#   allow_failure: true
#
# # Enables python bindings
# MacOS:Python:
#   stage: build
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     # Note here that if you brew boost libraries, you will encounter errors when cmake tries to find it. It is not located in /usr/local/lib when installed via brew.
#     - cmake -DBUILD_PYTHON_BINDINGS=ON ../VISR
#     # - make
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS
#   allow_failure: true

#
# Linux:Python:
#   stage: build
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake -DBUILD_PYTHON_BINDINGS=ON ../VISR
#     - make
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - linux
#     - ubuntu16
#   allow_failure: true
#
#
# ########### compile ###########
#
# MacOS:Core:
#   stage: compile & test
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake ../VISR
#     - make
#     - ctest -C Debug -j8
#     - ctest -R rrl_test
#     - ctest -j8 -R
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - macOS
#   allow_failure: true
#
# Linux:Core:
#   stage: compile & test
#   before_script:
#     - if [ -d ../build ] ; then rm -R ../build; fi
#   script:
#     - cd ../ && mkdir build && cd build
#     - cmake ../VISR
#     - make
#     - ctest -C Debug -j8
#     - ctest -R rrl_test
#     - ctest -j8 -R
#   after_script:
#     - cd ../ && rm -R build
#   only:
#     - feature/sphinx-ci-integration
#   tags:
#     - linux
#     - ubuntu16
#   allow_failure: true
#   # variables:
#   artifacts:
#     paths:
#     - Testing/*.log
#     expire_in: 1 week

########### deploy ############

#You can only use paths that are within the project workspace. To pass artifacts between different jobs, see dependencies.

VISRWebAPI:
  stage: deployment
  # before_script:
  #   - if [ -d ../build ] ; then rm -R ../build; fi
  script:
    # - mkdir build && cd build
    # - cmake -DBUILD_DOCUMENTATION_SPHINX=ON ..
    # - make doxy
    # - make webapi
    # is this accessing the id_rsa private or public key?
    # -r recursive, -h human-readable, -z compress -v versbose
    # --delete delete extreneous files from dest dirs
    # -e specify the remote shell to use with
    # ssh -i identity file which contains the private key. Teh default is ~/.ssh/id_dsa, ecdsa, id_rsa.
    # Where does wm0014 directory begin ? is this cwd? or goes to $HOME?

    #
    # rsync av --update /loc1 /loc2
    # av --update so only files that are NEWER will be synced from loc1 to loc2. Logic dictates that any files that are NEWER on loc2 will be # untouched. Therefore all the      outdated files on loc2 will be up-to-date thanks to loc1
    # - yes | cp -rf doc/sphinx /vol/vssp/dataweb/data/s3a/public/VISRWeb
    # - rsync -hrvz --update -e "ssh -i " wm0014@cvssp.org:~/.ssh/builds/cfa3a610/0/s3a/VISR/build/doc /vol/vssp/dataweb/data/s3a/public/VISRWeb
    # - cd build/doc/sphinx && ls -la
    - rsync -harvz --update ~/.ssh/builds/cfa3a610/0/s3a/VISR/build/ /vol/vssp/dataweb/data/s3a/public/VISRWeb
  # # Each time a job suceeds , a deployment is recorded, remembering the git SHA and environment name.
  # environment:
  #   name: staging
  #   url: ???
  # artifacts:
  #   paths:
  #     - build/doc/sphinx
  # after_script:
  dependencies:
    - Linux:Build
  only:
    - feature/sphinx-ci-integration
  tags:
    - linux
    - ubuntu16
