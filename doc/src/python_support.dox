/**
@page python_support Python support in VISR
 
@tableofcontents


@section python_support_overview Python Support Overview
The VISR framework aims at a seemless integration with Python. This supports four different ways (which can be
combined arbitrarily):
 * Controlling VISR signal flows from Python, e.g., starting, pausing and stopping processing.
 * Simulating the run of signal flows interactively in a Python development environment.
 * Extending and creating new signal flows by combining existing components in Python
 * Implementing new components in Python, which can be freely mixed and composed with other components.


@section python_support_installation_and_setup  Installation and Setup
To use the Python integration, a working Python environment must be installed both on a development system and on systems which use installed VISR binaries.
 * We highly recommend Python 3 (although the code should compile and run with Python 2 (provided that it is
built correctly), no testing is performed for that combination.
 * On Linux, the versions provided by the package manager (python3-dev, python3-*, spyder3) are fine. On
Windows, we recommend the Anaconda distribution https://www.continuum.io/ (Python 3, 64 Bit).
On Mac OS X, we also recommend Anaconda. The default adistribution of the OS image is outdated (Python 2.7)

@section building_python_externals Building the Python externals
To build the code on a development machine, the follwoing options must be set in CMAKE: Activate the option <tt>BUILD_PYTHON_BINDINGS</tt>. After running "Configure", check the settings in the newly appeared group <tt>PYTHON</tt>:
 * The setting <tt>PYTHON_INCLUDE_DIR</tt> must point to the include directory of the Python distribution.
Amongst others, this directory must contain the main Python header Python.h. If that
is not the case, set the entry to this directory. On the development systems, the following directories
are set:
   - Linux (Ubuntu 14.04 LTS 64 Bit): <tt>/usr/include/python3.4m</tt>
   - Windows (Anaconda 64 Bit): <tt>C:/Program Files/Anaconda3/include</tt>
   - Mac OS (Anaconda): <tt>/Users/&lt;loginname&gt;/anaconda/include/python3.5m</tt>
   .
 * The setting <tt>PYTHON_LIBRARY</tt> must point to the main Python library. This file is located within the
directory root of the installed Python distribution (or in case of Linux, a standard library directory. On our test systems, the file names are as follows:
   - Linux (Ubuntu 14.04 LTS 64 Bit): <tt>/usr/lib/x86_64-linux-gnu/libpython3.4m.so</tt>
   - Windows (Anaconda 64 Bit): <tt>C:/Program Files/Anaconda3/libs/python35.lib</tt>
   - Mac OS (Anaconda): /Users/loginname/anaconda/lib/libpython3.5m.dylib
   .
 * In CMake, call "Configure" again and run "Generate"
 * Build the project (the Python externals are distributed over several targets, so "Build all" is the best option.
 
@section python_support_setting_up_runtime_env Setting up the runtime environment
The following steps are required regardless whether the externals were built on the computer itself, or whether they
were installed using an installation package (differences are noted). The Python modules are located in a directory,
either within the build directory or the installation root directory.
 * If the VISR has been installed, the Python modules are in <tt>$VISR_INSTALLATION_ROOT/python</tt>
 * If the code has been built, the extensions are located in <tt>$VISR_BUILD_DIRECTORY/python</tt>. In development
environments that support multiple configurations, their is a subdirectory Debug/ or Release/ within python.
Choose the build configuration you want to use (Release/ is typically faster, but does not yield sensible
information when used with a debugger). This path must be known to Python in order to find these extension
modules.
The recommended way to do that is to set the environment variable $PYTHONPATH to include this directory. If the
Python interpreter is run from the command line, this can be done by adding a line to $HOME/.bashrc.
@code
export PYTHONPATH=<path_to_extension_modules>:$PYTHONPATH
@endcode
If the Python interpreter is started from the GUI, the following approaches work.
 * On Windows, set the PYTHONPATH in "Control Center"->"System"->"Advanced system settings"->" -
Environment Variables". Setting it as a user variable is preferred if you want to use the VISR only as the
current user.
 * On Linux system, add the setting to $HOME/.profile
 * On MacOS X, (TODO: Fill in information)

Another way is to set the module search path within Python, e.g., a
script.
@code
import sys sys.path.append( ’path_to_python_modules’ )
@endcode
Obviously, that makes it less easy to pass scripts between different places because the paths are hardcoded.
On
Windows, we must also ensure that the shared libraries (DLLs) used by the Python extensions are in a directory
contained in the <tt>PATH</tt> variable (preferably the user environment variable unless you want to make it available to all
users).

That is, the PATH must contain this directory:
 * <tt>VISR_INSTALLATION_ROOT/lib</tt> if an installer package has been used, or
 * <tt>VISR_BUILD_DIRECTORY/lib/{Debug|Release}</tt> if the VISR has been built from the source. Match
that the build configuration Debug or Release matches that used in the PYTHONPATH variable.

@section python_support_python_runner Running Python Components as Standalone Application: python_runner

While it is possible to run Python components directly from a Python interpreter, there are also use cases where a signal flow defined in Python is preferably run as a standalone audio application.
The application <tt>python_runner<tt>, installed as part of the VISR package, can be used. This binary is started as a command-line application and runs the specified VISR component as a real-time rendering process using a specified audio interface.

The command line arguments are displayed by the <tt>--help</tt> option:
@code
$ ./python_runner --help
  -h [ --help ]                     Show help and usage information.
  -v [ --version ]                  Display version information.
  --option-file arg                 Load options from a file. Can also be used 
                                    with syntax "@<filename>".
  -D [ --audio-backend ] arg        The audio backend.
  -f [ --sampling-frequency ] arg   Sampling frequency [Hz]
  -p [ --period ] arg               Period (blocklength) [Number of samples per
                                    audio block]
  -m [ --module-path ] arg          Full pathe of the Python module to be 
                                    loaded.
  -c [ --python-class-name ] arg    Name of the Python class (must be a 
                                    subclass of visr.Component).
  -n [ --object-name ] arg          Name of the Python class (must be a 
                                    subclass of visr.Component).
  -a [ --positional-arguments ] arg Comma-separated list of positional options 
                                    passed to the class constructor.
  -k [ --keyword-arguments ] arg    Comma-separated list of named (keyword) 
                                    options passed to the class constructor.
  --audio-ifc-options arg           Audio interface optional configuration
  --audio-ifc-option-file arg       Audio interface optional configuration file
@endcode

@todo Describe options!


*/